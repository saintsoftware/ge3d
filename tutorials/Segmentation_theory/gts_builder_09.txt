The GTS Builder comes with a gts_builder.jpg. In here going to give the theory overview and at the jpg some interface info...

Since the code is used in a very straight foward way, one can easy build and implement a toold that build that
code for the user. 

So this is the place to build abstraction layers work for GTS, outside the scoop of programming...

One for example can have a database build that deals with:

MYSQL
ODBC
MongoDB
Oracle
...etc...

So the final code is not affected by abstraction layers while having the capability to use abstraction layers to develop
the software.

The GTS builder works in a simple way: it holds code snippets insinde folders with a separeted file for which snippets, so
when the builders loads it creates temporary files from the default snippets and the user edit this ones or reset to default's
so it have a code library that automates all for him while not affecting the code efficiency. When is necessary it builds the
app retaining the reference to the temp snippets, so the user can keep working with them.

A simple way is to do it with comments so it can be used with any editor:


// GTS Builder start :: character1
$character1;
// GTS builder end

// GTS Builder start :: character2
$character2;
// GTS builder end

// GTS Builder start :: main div, var #main
<div id='main'></div>
// GTS builder end


So when the GTS builder search inside those files it recognise these key phrases and loads the app to the builder:  

Another thing is comments since it, you can still add the other type of comments to the temp (\* another style */), 
which the GTS builder do not leave on the build app as it removes comment's to build but they will be there on the temp app. 

The code style can have any kind of abstraction library while not affecting your code:

A : load 2 lines of code
b : 3 lines
c : 10 lines;
f : 5 lines;

You are in charge of your own abstraction layer while the code remains style the same for all applications. Any one can 
code with the builder because if do not understand the abstraction some one created you can always read directly the code
which is the same. Actually very similar because it's loaded from the same default, so it add that plus to development.

Another stuff was already mention is that bug's are much more easy to fix because, it have all your variables loaded:
Database , database abstraction layer , vars, function, query's,  segments , logic tests, etc...

When for example a query logic do fail to provide a successful result the GTS builder can recognize and inform where is the
mistake and what is doing wrong. Another problem with code development we often need to build a bit more of complexity
to do code tests, so tests could also be build but they will not be there in the live app. So to develop and fix bugs.

for example a builder query :
$table = "users";
$user_id = 45;
$action  = "SELECT";
$rows = "*";
$where = "user = '$user_id' ";
$limit = "LIMIT 5";

mysqli_query ($db, "$action $rows FROM $table $where $limit"); // builder temporary code, to recognize logic mistakes...
mysqli_query ($db, "SELECT * FROM users WHERE  user_id = '45' LIMIT 5"); // live query

Code will be very high performance efficient while having the capability to work with abstraction layers.

If the build abstraction layer do fail to provide a answer you do not need to wait for a team to debug your code it will
still be there for you to improve it or update, it's a plus and not a absolute solution.

If one did some kind of mistake and need to load back to the GTS builder, can manually add the Builder tags back to the
code and it loads it back.

For example Start a resync on temp builder code;

So you made changes to a couple of functions and you don't want to copy past back to builder, add the tags in the specific
files functions and request a resync. The builder get only those tags and updates only those tags.

One can choose to continue to use the editor while remaining the possibility to do some test's inside the builder.

