{\rtf1\ansi\ansicpg1252\deff0\uc1
{\fonttbl
{\f0\fnil\fcharset0\fprq0\fttruetype Sans;}
{\f1\fnil\fcharset0\fprq0\fttruetype Times New Roman;}
{\f2\fnil\fcharset0\fprq0\fttruetype Liberation Sans;}
{\f3\fnil\fcharset0\fprq0\fttruetype Courier New;}}
{\colortbl
\red0\green0\blue0;
\red255\green255\blue255;
\red255\green255\blue255;}
{\stylesheet
{\s6\fi-431\li720\sbasedon28\snext28 Contents 1;}
{\s7\fi-431\li1440\sbasedon28\snext28 Contents 2;}
{\s1\fi-431\li720 Arrowhead List;}
{\s27\fi-431\li720\sbasedon28 Lower Roman List;}
{\s29\tx431\sbasedon20\snext28 Numbered Heading 1;}
{\s30\tx431\sbasedon21\snext28 Numbered Heading 2;}
{\s12\fi-431\li720 Diamond List;}
{\s9\fi-431\li2880\sbasedon28\snext28 Contents 4;}
{\s8\fi-431\li2160\sbasedon28\snext28 Contents 3;}
{\s31\tx431\sbasedon22\snext28 Numbered Heading 3;}
{\s32\fi-431\li720 Numbered List;}
{\s15\sbasedon28 Endnote Text;}
{\*\cs14\fs20\super Endnote Reference;}
{\s4\fi-431\li720 Bullet List;}
{\s5\tx1584\sbasedon29\snext28 Chapter Heading;}
{\s35\fi-431\li720 Square List;}
{\s11\fi-431\li720 Dashed List;}
{\s22\sb440\sa60\f2\fs24\b\sbasedon28\snext28 Heading 3;}
{\s37\fi-431\li720 Tick List;}
{\s24\fi-431\li720 Heart List;}
{\s40\fi-431\li720\sbasedon32 Upper Roman List;}
{\s39\fi-431\li720\sbasedon32 Upper Case List;}
{\s16\fi-288\li288\fs20\sbasedon28 Footnote;}
{\s19\fi-431\li720 Hand List;}
{\s18\fs20\sbasedon28 Footnote Text;}
{\s20\sb440\sa60\f2\fs34\b\sbasedon28\snext28 Heading 1;}
{\s21\sb440\sa60\f2\fs28\b\sbasedon28\snext28 Heading 2;}
{\s10\qc\sb240\sa120\f2\fs32\b\sbasedon28\snext28 Contents Header;}
{\s23\sb440\sa60\f2\fs24\b\sbasedon28\snext28 Heading 4;}
{\s28\f1\fs24 Normal;}
{\s26\fi-431\li720\sbasedon32 Lower Case List;}
{\s2\li1440\ri1440\sa120\sbasedon28 Block Text;}
{\s33\f3\sbasedon28 Plain Text;}
{\s34\tx1584\sbasedon29\snext28 Section Heading;}
{\s25\fi-431\li720 Implies List;}
{\s3\fi-431\li720 Box List;}
{\s36\fi-431\li720 Star List;}
{\*\cs17\fs20\super Footnote Reference;}
{\s38\fi-431\li720 Triangle List;}
{\s13\fi-288\li288\sbasedon28 Endnote;}}
\kerning0\cf0\ftnbj\fet2\ftnstart1\ftnnar\aftnnar\ftnstart1\aftnstart1\aenddoc\revprop3{\*\rdf}{\info\uc1{\author jdc}}\deftab720\viewkind1\paperw11905\paperh16837\margl1440\margr1440\widowctrl
\sectd\sbknone\colsx360\pgncont\ltrsect
\pard\plain\ltrpar\ql\s28\itap0{\s28\f0\fs24\lang2070{\*\listtag0}\abinodiroverride\ltrch \uc0\u-257 }{\s28\f0\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f0\fs24\lang2070{\*\listtag0}\abinodiroverride\ltrch \tab \tab 3D game engine for Linux in C }{\s28\f0\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\li1440\ri1440\sa120\s2\itap0{\s2\f0\fs24\lang2070{\*\listtag0}\abinodiroverride\ltrch 3D game engine for Linux\line  \line I like to develop a game engine for Linux, since the community is growing fast and demanding games, not a big fun of frameworks i kind like to Wright the code my self.\line  \line But I may be in believe that the spaghetti code generated in procedural is a obstacle in developing quality code, but I think it's a logical problem that I will attempt to explain.\line  \line The logic in the human mind only works in 2 way's:\line  \line Generic -> to -> Singularity\line  Singularity -> to -> Generic\line  \line This are the only two possible ways of thinking. There for we can decompose this in to a tree structure:\line  \line | | < ---- tree top : Procedural / Segmentation / Generic\line  | |\line  / \\ / \\ \line / | | \\ / \\ \\/ \\ <--- tree roots : OOP / Class / Singularity\line  \line \line The OOP is designed using the Singularity to Generic (STG) logic composition, you can start the development at the base, and then climb your way to the top. This allows a very loose way of coding. By it self your code is already structure in a logical composition though is not connected with other things at the time of development.\line  \line Procedural does not start with Singularity. It starts with a Generic approach. This means that you can't start building from the bottom to the top. It will not work was it does with OOP. You can't use in in this way because it is not logic connected to it self, and it will break eventually at some point.\line  \line The logical use in top to bottom I call it Segmentation or Generic to Singularity (GTS) logic composition.\line  \line Going to explain GTS in example since I assume that OOP is clear to every one:\line  \line Example of PHP Procedural (GTS) front Controller:\line  \line -----------------------\line  index.php\line  -------------------------\line  \line Session_Start();\line  Define "Page_Validation" = true;\line  \line if("user loged in" )\{\line  // Load the login page\line  \}else\{\line  // Load the Entrance Page\line  \}\line  \line ---------------------------------------\line  \line If you think on the tree example you will see that this front controller is the WOOD, and the rest is the roots of the wood in a structured way.\line  \line A structure in GTS or Segmentation:\line  \line Front Controller -> Loads Pages\line  Pages -> Load module\line  Module -> Load output\line  \line What is achievable in this way is that, the code can be reeded in a logical way, was it is in OOP Classes.\line  \line Explaining the advantages: in pure GTS hardly is necessary any kind of function declaration unless you really need to. Since is Segmented, the variable declared at the top level will be used in the lower levels.\line  \line -----------------------\line  main.php\line  -------------------------\line  \line $db_user = 'my_user';\line  $db_pass = 'my_pass';\line  $db_host = 'my_host';\line  $db_table = 'my_table';\line  \line ------------------------------\line  \line The main page is a main tree root is where you will load the stuff for the all of your modules, since it is coded in Segmentation you do not need to make a very hard to read code which is a function inside a function and in some cases inside a function.\line  \line -----------------------\line  module.php\line  -------------------------\line  \line $db = mysqli_connect($db_host, $db_user, $db_pass, $db_table) or die("Fail to load database.");\line  \line -----------------------------\line  \line Since is segmented the code does not need another function to connect to the DB. The build in function is called directly.\line  \line So no adicional function declaration is necessarity to besides the functions that already come with the WEB PHP modules to executed the tasks that where planed to be executed. Because things are planed in a segmented way or GTS logic composition. When you reach the botom levels\line  you know what you have available by them using segmentation planification.\line  \line The non logic structured code or NLSC also called spaghetti code is subjective code, and unless you are the person that wrote the code since it does not have a logic structure that all people are capable of reading eventualy it will lead to wasted of time.\line  \line My experience in developing Segmentation that you only need to have a couple of things to look at which are the way of declare your variables, you must be very expecific at this stuff because you need convetion at the variable naming.\line  \line In general Procedural is a proper style of coding, but since some one skipped the philosophic classes where the principles of logic where debated guess they will be in the forums in the endless battle of OOP vs Procedural coding...\line  \line What is better?\line  \line GTS is better because you need to plan all things in advancement it will create less amount of code.\line  \line The STG is still necessary if this was real life we could translate to:\line  \line STG takes less time to achive results, you only need a couple of examples to achive the Generic Perspective or conclusion.\line  \line GTS uses more information when planning there for is much more efficient, though slower but more efficient.\line  \line STG is used in real life to make fast decisions, to achieve a Generic perspective a couple of examples will do, but the final result can't compete with GTS proper panification.\line  \line ---------------------------------\line  \line Microsoft stop XP support and half corporate world still use it, I move to Linux since I do not\line  have a very powerful machine, and I think my machine is still doing ok in XP.\line  \line The procedural engines for what I read stooped with Quake 3 GPL 3D engine, which is a shame because those engines could reach a better efficiency, and make useful older machines.\line  \line The Quake GPL engine is very subjective builded (NLSC), unless you are the person that Wright the engine you will have a hard time to understand any thing from it.\line  \line Here is a example of the GTS logic composition could be applied to the new 3D engine:\line  \line \line --------------------\line  Engine Front Controller:\line  -----------------\line  \line int main ()\{\line  \line /*\line  what is common to all our pages? To start with Window/resolution is the stuff that all the modules will use. So this makes a very clean readable and probably reusable code of a front controller and is this simple...\line  */\line  \line //screen resolution window loading\line  \line if(game_loading)\{\line  //load game\line  \} \line else if(main_menu)\{\line  //load main menu\line  \}\line  \line \}\line  \line ------------------------------------\line  \line A very logical front controller only load generic common stuff, that will be common to all Segments any thing else is not loaded, this is proper logic GTS composition.\line  \line Why only load common? There are many reasons, but for this example:\line  \line Because when you reach next level, you know that the previous example is already loaded and it have no bugs, in a way GTS is kind a Linux structure. It do not loaded on top of which other. That means that if we have a bug at the 3D env, in theory you can still go back to the menu with out breaking the hole structure. We can find that a 3D bug is only at the 3D segment, that the previus segment the windows env is tested and working, in a way that is not possible for the non logic structured code (NLSC).\line  \line Lets imagine that we start loading 3D libraries that are going to be necessary for the 3D enviorment at the top level, readability will also be affected, understanding what going one also very affected, and so on....\line  \line The human mind understand Logic structures...\line  \line The code structure can still be synthesised untill all scheme is proper logic structured, but it can only be done in a GTS or STG logic composition.\line  \line ----------------------------------\line  \line What you people think about this concepts they make any logic for you people?\line  \line --------------------------------\line  \line Links:\line  \line continus development of Quake3 GPL engine : }{\field{\*\fldinst {\f0\fs24\lang2070{\*\listtag0} HYPERLINK "https://github.com/zturtleman/spearmint"}}{\*\fldrslt{\s2\f0\fs24\lang2070{\*\listtag0}https://github.com/zturtleman/spearmint}}}{\s2\f0\fs24\lang2070{\*\listtag0}\line  Quake3 GPL engine : }{\field{\*\fldinst {\f0\fs24\lang2070{\*\listtag0} HYPERLINK "https://github.com/ioquake/ioq3"}}{\*\fldrslt{\s2\f0\fs24\lang2070{\*\listtag0}https://github.com/ioquake/ioq3}}}{\s2\f0\fs24\lang2070{\*\listtag0}\line  \line My project page: saintsoftware.eu.pn\line  A fantasy browser game : tidesoftime.eu.pn\line  A browser RPG game : battleofworlds.eu.pn\line  A online battle arena for Linux community : mediveltitans.eu.pn\line  \line Contact:\line  \line }{\field{\*\fldinst {\f0\fs24\lang2070{\*\listtag0} HYPERLINK "mailto:general@saintsoftware.eu.pn"}}{\*\fldrslt{\s2\f0\fs24\lang2070{\*\listtag0}general@saintsoftware.eu.pn}}}{\s2\f0\fs24\lang2070{\*\listtag0} }{\s2\f0\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\li1440\ri1440\sa120\s2\itap0{\s2\f0\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\li1440\ri1440\sa120\s2\itap0{\s2\f0\fs24\lang2070{\*\listtag0}\abinodiroverride\ltrch Perspective:}{\s2\f0\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\li1440\ri1440\sa120\s2\itap0{\s2\f0\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\li1440\ri1440\sa120\s2\itap0{\s2\f1\fs24\lang2070{\*\listtag0}\abinodiroverride\ltrch \uc0\u-257 this will be a open source project, and the perspective for the project will be a bit on learning. Oriented for those like my self that wish to learn I a bit more on game engines. Though I have no intention to start writing a full engine from scratch and I think that will be very unrealistic thing to do. I will be more refactoring some code, and develop simple functionality when needed. \line \line A process for learning...\line  \line My first stage will be to refactor a image library to able to load images... You will probably find basic tutorials and advanced tutorials at the project account if you have a intention to learn a bit also, the end result will be available to all, so participated can be useful in both ways in terms of learning and in terms of end result.}{\s2\f1\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f1\fs24\lang2070{\*\listtag0}\abinodiroverride\ltrch \uc0\u-257 }{\s28\f1\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\li1440\ri1440\sa120\s2\itap0{\s2\f1\fs24\lang2070{\*\listtag0}\abinodiroverride\ltrch Loose set of objectives :\line  \line I already written a post with the planning of the structure that I desired but I didn't post it at this time so that I don't fall victim of my lack of experience with the language. Reading a book on how to develop games for Linux, and doing the standard C tutorials.\line  \line  \line GTS / STG history background:\line  \line I like to use proper concepts on things, procedural and OOP where not what they are today a couple of years ago they evolved and created their own concepts and methods. Talking about of procedural in a society that does not use it very much, or opposes to it structures does not add to the public image of the code style. By other side if people understand the concepts that may be behind it, at the mind of their developers, which are the true intention the author imagined for the language then maybe people see things in a different way...\line  \line Question: don\uc1\u8221\'94t understand Procedural: \line \line OOP can be poorly implement but still is OOP because is at the root level much harder to make mistakes, while at procedural you are at the wood level on the top you can make a lot of mistakes and enter very easy in to the NLSC (non logic structure code). That eventually will consume you time,\line  and possible break your code. \line \line Question: what exactly you want to do :\line  \line Though i already did the planning and did not post it, that does not mean I should assume every thing by my self there's a lot of room for others to come forward and give their opinion on the structure, though it may be difficult with out the initial structure.\line  \line I should have a bit more knowledge with the language before making assumptions, but I will give it a try...\line  \line Questin: Can you advanced a structure?:\line  \line ----------------------------\line  New include format\line  ---------------------------\line  \line #include image_lib\line  #include jpg_sub\line  //#include png_sub\line  \line -------------------------------\line  \line To start with I want to separate things at the top level, the image_lib only include the main structure, so that when jpg is loaded there is not loaded PNG, GIF, PSD, BMP, etc file formats. This is the first level of structure that I want to implement. Create depend libraries, if you load jpg_sub\line  it will give you a dependency error for the main lib.\line  \line This will prevent from having a file with 4.000 lines of code, or have a internal sub structure inside the files which will decrease your readability and understanding of what is happening, that could possible be starting to originate NLSC.\line  \line In theory a new type of image module could be loaded by depopulating the way image library is loading to a system. So if a Android system come along and need a new module in theory is possible to load one with out affecting the sub libraries.\line  \line \line Now that we separated the top level will need to continue with Segmentation for the JPG Settings,\line  \line Arrays are very common used in frameworks, I like them a lot, so build the settings in array format thing will be a very nice thing to do.\line  \line --------------------------\line  JPG Sub Library\line  --------------------------\line  \line #include "A" // Standard set of settings loaded\line  //#include "B" \line //#include "C" \line \line /*\line  The comment configuration is very adopted at the linux configuration files, so is something that may a bit strange directly on the code but think people can adopted fairly easy\line  */\line  \line //...call use in the next file ... jpg_settings = \{a, c\}\line  \line ...code to process array...\line  \line array char jpg_settings\{3\} =\{false, false, false\} \line \line if(jpg_settings[0] == true)\{\line  // load setting A file\line  \}\line  \line if(jpg_settings[1] == true)\{ \line // load setting B file\line  \}\line  \line if(jpg_settings[2] == true)\{ \line // load setting C file\line  \}\line  \line ----------------------------\line  \line This will Segmented the code in to settings so only the stuff that is necessary is load throw the module.\line  \line --------------------------\line  Image Library loading \line --------------------------\line  \line int main()\{\line  module = image_module(); // load the "include image_lib" module\line  \line ***my lack of knowledge prevents me to understand the "how" of the loading module***.\line  \line array jpg_settings = \{a,b,c\} //loads the JPG settings in a array format:\line  \line jpg_settings.a = "true" // A structure could be use to the same thing, but is very common to used the array format, and I personally prefer them was they offer more readability, we do read in line...\line  \line jpg(module, "images/image_01.jpg", jpg_settings); // load the JPG module + file + settings. Separated the variables with the string in the middle to make it a bit easy to read and memorise...\line  \line \}\line  \line ----------------------------\line  \line * This is a basic Segmentation with my poor C knowledge I do not know if is necessary further or better Segmentation. I read 1/10 tutorial on C and leave another at beginning just to check the content. The book is at 150 pages of 470 or so...\line  \line In theory the Segmentation will only load 1k of the 4k image library that I find on the internet. There for creating a usable logic structure.\line  \line Readability is increased, since now the code is structure in a logic format. Probably less bug's since less code is loaded, and so one... already explained that stuff...\line  \line Needed a bit more knowledge, but with the principle that I designed if you already have the knowledge in C that it can be easy improved further to Segmented even more the code to the extend of necessity.\line  \line At this stage need to know more on what is happening to defined more rules. }{\s2\f1\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f1\fs24\lang2070{\*\listtag0}\abinodiroverride\ltrch \tab \tab Question: Don\uc1\u8221\'94t understand the concepts}{\s28\f1\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f1\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f1\fs24\lang2070{\*\listtag0}\abinodiroverride\ltrch  \uc0\u-257 It's not possible to explain Procedural vs OOP with out concepts. They allow us to understand things, how things works. Einstein concept about the theory of relativity is very simple E = mc(2), this is a very simple concept once people understand how it works, but they need it in order to know how it works. A concept is a way of explaining things in a much simpler way.\line  \line With out the GTS and STG concepts I probably instead of 50 lines of writing will needed to write a full book on logic so that people could understand what I'm talking about.}{\s28\f1\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f1\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f1\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f1\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f1\fs24\lang2070{\*\listtag0}\abinodiroverride\ltrch ---------------------------------}{\s28\f1\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f1\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f1\fs24\lang2070{\*\listtag0}\abinodiroverride\ltrch \uc0\u-257 }{\s28\f1\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\li1440\ri1440\sa120\s2\itap0{\s2\f1\fs24\lang2070{\*\listtag0}\abinodiroverride\ltrch I may have made an assumption which is causing some difficulty to understand...\line  \line Procedural due to it's loose style allows : GTS & STG.\line  \line while OOP due to it's strict set of rules only allows : STG.\line  \line Since the human mind use both logic compositions to think, when some one wants to code in Procedural it will have a very hard time since it does\line  not know that the machine does not re-arranges by it self was the brain does.\line  \line So if a person does not follow only one logic composition path it will fall in to the NLSC very easy. That's the major struggle or battle over the years that programming language developers have faced.\line  \line With this in regard that does not mean that the STG path is a better structure then GTS it means that the coder needs to understand the concepts\line  before he goes to code in Procedural. It needs to understand that GTS works in Segmentation while the OOP works in classes. To understand this\line  read the three example that attempt to explains this.\line  \line If I'm successful in coding my 3D engine maybe it will serve as some example on how to implement Segmentation on a larger scale so far I only implemented in a small scale which is my web pages.\line  \line "A convention on GTS logic structure may be a good thing?" }{\s2\f1\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f1\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f1\fs24\lang2070{\*\listtag0}\par}
\pard\plain\ltrpar\ql\s28\itap0{\s28\f1\fs24\lang2070{\*\listtag0}\abinodiroverride\ltrch \tab \tab *May need to do a little re-writte to the theory lather...}{\s28\f1\fs24\lang2070{\*\listtag0}\par}}